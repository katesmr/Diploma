var keyDuration = require("../utils/keyDuration");
var TrackManager = require("../utils/TrackManager");

module.exports = AudioBufferRecorder;

function AudioBufferRecorder(trackModel){
    this.track = null;
    this.playData = null;
    this.duration = 0;
    this.trackModel = trackModel;
    this.createTrack();
}

/**
 * Again create track and filters for record them to Offline
 */
AudioBufferRecorder.prototype.createTrack = function(){
    switch(this.trackModel.instrument){
        case "synth":
            this.track = new Tone.Synth(this.trackModel.setting).toMaster();
            this.createFilters();
            this.playData = createSynthPlayData(this.trackModel.playObjects);
            this.duration = keyDuration(this.playData);
            break;
        case "drum":
            this.track = null;
            break;
        case "oscillator":
            this.track = new Tone.Oscillator();
            break;
        case "noise":
            this.track = new Tone.NoiseSynth();
            break;
    }
};

AudioBufferRecorder.prototype.createFilter = function(filterObjects, filterName, filterSetting){
    switch(filterName){
        case "tremolo":
            filterObjects[filterName] = new Tone.Tremolo(filterSetting);
            break;
        case "vibrato":
            filterObjects[filterName] = new Tone.Vibrato(filterSetting);
            break;
        case "crusher":
            filterObjects[filterName] = new Tone.BitCrusher(filterSetting);
            break;
        case "phaser":
            filterObjects[filterName] = new Tone.Phaser(filterSetting);
            break;
        case "freeverb":
            filterObjects[filterName] = new Tone.Freeverb(filterSetting);
            break;
    }
};

AudioBufferRecorder.prototype.createFilters = function(){
    var name;
    var filterObjects = {};
    for(name in this.trackModel.postSettings.postSettings){
        this.createFilter(filterObjects, name, this.trackModel.postSettings.postSettings[name]);
    }
    console.log("++++");
    console.log(filterObjects);
    this.applyAllFiltersToTrack(filterObjects);
};


/**
 * Apply all filters from filterObjects to one track
 */
AudioBufferRecorder.prototype.applyAllFiltersToTrack = function(filterObjects){
    var name, filter;
    for(name in filterObjects){
        filter = filterObjects[name];
        console.log("---------");
        console.log(filter);
        filter.toMaster();
        this.track.disconnect(Tone.Master);
        this.track.connect(filter);
    }
};

AudioBufferRecorder.prototype.play = function(instrument, value){
    switch(instrument){
        case "synth":
            this.track.triggerAttackRelease(value.note, value.duration, value.time);
            break;
        case "drum":
            break;
        case "oscillator":
            break;
        case "noise":
            break;
    }
};

AudioBufferRecorder.prototype.record = function(callback){
    var self = this;
    Tone.Offline(function(){
        self.createTrack(self.trackModel.instrument);
        var part = new Tone.Part(function(time, value){
            self.play(self.trackModel.instrument, value);
            console.log(value.note, time, value.duration);
        }, self.playData);
        part.start(0);
        Tone.Transport.start();
    }, this.duration).then(function(buffer){
        console.log(buffer);
        console.log(buffer._buffer);
        TrackManager.save(buffer._buffer);
    });
};

function createSynthPlayData(trackPlayData){
    var events = [];
    var tmp, i;
    for(i = 0; i < trackPlayData.length; ++i){
        tmp = {};
        tmp.time = trackPlayData[i].triggerAttackTime / 1000;
        tmp.duration = trackPlayData[i].triggerReleaseTime / 1000;
        tmp.note = trackPlayData[i].note;
        events.push(tmp);
    }
    return events;
}
